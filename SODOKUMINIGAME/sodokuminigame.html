<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SUDOKU MINI: THE PIXEL GRID</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: #0a0a0a;
            color: #ffffff;
            font-family: 'JetBrains Mono', monospace;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            overflow-x: hidden;
        }

        /* New start screen styles (matches 2048) */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 20px;
            text-align: center;
        }

        #gameTitle {
            font-size: clamp(2rem, 10vw, 3rem);
            font-weight: 300;
            color: #fff;
            margin-bottom: 2rem;
            letter-spacing: 0.5rem;
            opacity: 0.9;
            font-family: 'Courier New', monospace;
        }

        #startBtn {
            background: transparent;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 1rem 2rem;
            font-family: 'Courier New', monospace;
            font-size: clamp(0.9rem, 4vw, 1rem);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.2rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 200px;
        }

        #startBtn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-2px);
        }

        #instructions {
            margin-top: 2rem;
            text-align: center;
            font-size: clamp(0.7rem, 3vw, 0.8rem);
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.6;
            font-weight: 300;
            font-family: 'Courier New', monospace;
            max-width: 300px;
        }

        /* Original game styles below (unchanged) */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 255, 255, 0.03) 2px,
                rgba(255, 255, 255, 0.03) 4px
            );
            z-index: 1000;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            width: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .game-screen {
            display: none;
            width: 100%;
            max-width: 1200px;
            padding: 10px;
        }
        
        .game-header {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 0 0.5rem;
            gap: 0.5rem;
            width: 100%;
        }
        
        .game-title {
            font-size: clamp(0.8rem, 4vw, 1.5rem);
            font-weight: 700;
            text-align: center;
        }
        
        .game-stats {
            display: flex;
            gap: 1rem;
            font-size: clamp(0.7rem, 3vw, 0.9rem);
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
        }
        
        .game-content {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            justify-content: center;
            align-items: center;
            width: 100%;
        }
        
        .sudoku-grid {
            border: 3px solid #fff;
            background: #000;
            display: grid;
            gap: 1px;
            margin: 0 auto;
            touch-action: manipulation;
        }
        
        .grid-4x4 { grid-template-columns: repeat(4, min(18vw, 50px)); }
        .grid-6x6 { grid-template-columns: repeat(6, min(14vw, 45px)); }
        .grid-9x9 { grid-template-columns: repeat(9, min(10vw, 40px)); }
        
        .sudoku-cell {
            background: #000;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1rem, 4vw, 1.2rem);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            aspect-ratio: 1/1;
        }
        
        .grid-4x4 .sudoku-cell { width: min(18vw, 50px); height: min(18vw, 50px); }
        .grid-6x6 .sudoku-cell { width: min(14vw, 45px); height: min(14vw, 45px); }
        .grid-9x9 .sudoku-cell { width: min(10vw, 40px); height: min(10vw, 40px); }
        
        .sudoku-cell:hover {
            background: #111;
            box-shadow: inset 0 0 10px #fff;
        }
        
        .sudoku-cell.active {
            background: #222;
            border: 2px solid #fff;
            box-shadow: 0 0 15px #fff;
        }
        
        .sudoku-cell.prefilled {
            color: #888;
            cursor: default;
        }
        
        .sudoku-cell.prefilled:hover {
            background: #000;
            box-shadow: none;
        }
        
        .sudoku-cell.error {
            animation: shake 0.5s, flash-red 0.3s;
        }
        
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            width: 100%;
            max-width: 300px;
        }
        
        .panel-section {
            border: 1px solid #fff;
            padding: 0.8rem;
            background: #000;
        }
        
        .panel-title {
            font-size: 0.7rem;
            margin-bottom: 0.5rem;
            color: #888;
        }
        
        .panel-value {
            font-size: 0.9rem;
            font-weight: 700;
        }
        
        .mistake-counter {
            color: #fff;
        }
        
        .mistake-counter.danger {
            color: #ff4444;
            animation: pulse 1s infinite;
        }
        
        .game-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        button {
            background: #000;
            color: #fff;
            border: 2px solid #fff;
            padding: 8px 16px;
            font-family: inherit;
            font-size: clamp(0.7rem, 3vw, 0.9rem);
            text-transform: uppercase;
            cursor: pointer;
            image-rendering: pixelated;
            transition: all 0.2s;
            -webkit-appearance: none;
            appearance: none;
        }
        
        button:hover {
            background: #fff;
            color: #000;
            box-shadow: 0 0 10px #fff;
        }
        
        .game-options {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .game-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.7rem;
        }
        
        select {
            background: #000;
            color: #fff;
            border: 2px solid #fff;
            padding: 4px 8px;
            font-family: inherit;
            font-size: 0.7rem;
            text-transform: uppercase;
            cursor: pointer;
            image-rendering: pixelated;
            transition: all 0.2s;
            -webkit-appearance: none;
            appearance: none;
            width: 100px;
        }
        
        select:hover {
            background: #fff;
            color: #000;
            box-shadow: 0 0 10px #fff;
        }
        
        .win-screen, .lose-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 500;
            padding: 20px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .win-message, .lose-message {
            text-align: center;
            font-size: clamp(1.5rem, 8vw, 2rem);
            font-weight: 700;
            animation: flicker 1s infinite;
        }
        
        .win-screen {
            animation: win-flash 2s infinite;
        }
        
        .lose-screen .lose-message {
            color: #ff4444;
            animation: glitch 0.5s infinite;
        }
        
        .win-screen button, .lose-screen button {
            margin-top: 1.5rem;
            font-size: clamp(0.8rem, 4vw, 1rem);
            padding: 10px 20px;
        }
        
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
            20%, 40%, 60%, 80% { transform: translateX(2px); }
        }
        
        @keyframes flash-red {
            0%, 100% { background: #000; }
            50% { background: #440000; }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes win-flash {
            0%, 100% { background: rgba(0, 0, 0, 0.9); }
            50% { background: rgba(255, 255, 255, 0.1); }
        }
        
        @keyframes glitch {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-2px) translateY(2px); }
            40% { transform: translateX(2px) translateY(-2px); }
            60% { transform: translateX(-2px) translateY(-2px); }
            80% { transform: translateX(2px) translateY(2px); }
        }
        
        @keyframes sparkle {
            0% { transform: scale(0) rotate(0deg); opacity: 1; }
            100% { transform: scale(1) rotate(360deg); opacity: 0; }
        }
        
        @keyframes flash-white {
            0%, 100% { background: rgba(0, 0, 0, 0.9); }
            50% { background: rgba(255, 255, 255, 0.9); }
        }
        
        .sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #fff;
            pointer-events: none;
            animation: sparkle 0.6s ease-out forwards;
        }
        
        /* Number pad for mobile */
        .number-pad {
            display: none;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            margin-top: 1rem;
            width: 100%;
            max-width: 300px;
            touch-action: manipulation;
        }
        
        .number-pad button {
            aspect-ratio: 1/1;
            font-size: clamp(1rem, 4vw, 1.2rem);
            padding: 0;
            min-height: 40px;
        }
        
        .number-pad button.clear {
            grid-column: span 2;
            aspect-ratio: auto;
        }
        
        @media (max-width: 768px) {
            .number-pad {
                display: grid;
            }
            
            .game-header {
                flex-direction: column;
                align-items: center;
            }
            
            .game-stats {
                justify-content: center;
            }
            
            .side-panel {
                max-width: 100%;
            }
            
            .game-content {
                flex-direction: column;
            }
            
            .sudoku-grid {
                order: 1;
            }
            
            .number-pad {
                order: 2;
            }
            
            .side-panel {
                order: 3;
            }
        }
        
        @media (max-width: 480px) {
            .grid-4x4 { grid-template-columns: repeat(4, min(20vw, 50px)); }
            .grid-6x6 { grid-template-columns: repeat(6, min(15vw, 45px)); }
            .grid-9x9 { grid-template-columns: repeat(9, min(10vw, 40px)); }
            
            .grid-4x4 .sudoku-cell { width: min(20vw, 50px); height: min(20vw, 50px); }
            .grid-6x6 .sudoku-cell { width: min(15vw, 45px); height: min(15vw, 45px); }
            .grid-9x9 .sudoku-cell { width: min(10vw, 40px); height: min(10vw, 40px); }
            
            .game-stats {
                flex-direction: column;
                align-items: center;
                gap: 0.5rem;
            }
            
            .panel-section {
                padding: 0.5rem;
            }
            
            .game-option {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.3rem;
            }
            
            select {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="scanlines"></div>
    
    <!-- New start screen (matches 2048) -->
    <div id="startScreen">
        <h1 id="gameTitle">SUDOKU MINI</h1>
        <button id="startBtn">START</button>
        <div id="instructions">
            FILL THE GRID WITH UNIQUE DIGITS<br>
            NO REPEATS IN ROWS, COLUMNS OR BOXES<br>
            THREE MISTAKES AND YOU'RE OUT
        </div>
    </div>

    <div class="container">
        <div class="game-screen" id="gameScreen">
            <div class="game-header">
                <div class="game-title">SUDOKU MINI: THE PIXEL GRID</div>
                <div class="game-stats">
                    <div>TIME: <span id="timer">00:00</span></div>
                    <div>MISTAKES: <span id="mistakes" class="mistake-counter">0/3</span></div>
                    <div>HINTS: <span id="hints">3</span></div>
                </div>
            </div>
            
            <div class="game-content">
                <div class="sudoku-grid" id="sudokuGrid"></div>
                
                <div class="number-pad" id="numberPad">
                    <button onclick="inputNumber(1)">1</button>
                    <button onclick="inputNumber(2)">2</button>
                    <button onclick="inputNumber(3)">3</button>
                    <button onclick="inputNumber(4)">4</button>
                    <button onclick="inputNumber(5)">5</button>
                    <button onclick="inputNumber(6)">6</button>
                    <button onclick="inputNumber(7)">7</button>
                    <button onclick="inputNumber(8)">8</button>
                    <button onclick="inputNumber(9)">9</button>
                    <button onclick="inputNumber(0)" class="clear">CLEAR</button>
                </div>
                
                <div class="side-panel">
                    <div class="panel-section">
                        <div class="panel-title">STATUS</div>
                        <div class="panel-value" id="status">PLAYING</div>
                        
                        <div class="game-options">
                            <div class="game-option">
                                <span>GRID SIZE:</span>
                                <select id="gridSize">
                                    <option value="4">4×4</option>
                                    <option value="6">6×6</option>
                                    <option value="9">9×9</option>
                                </select>
                            </div>
                            
                            <div class="game-option">
                                <span>DIFFICULTY:</span>
                                <select id="difficulty">
                                    <option value="easy">EASY</option>
                                    <option value="medium" selected>MEDIUM</option>
                                    <option value="hard">HARD</option>
                                </select>
                            </div>
                            
                            <div class="game-option">
                                <span>AUTO-CHECK:</span>
                                <select id="autoCheck">
                                    <option value="true" selected>ON</option>
                                    <option value="false">OFF</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="panel-section game-buttons">
                        <button onclick="getHint()">HINT</button>
                        <button onclick="restartGame()">RESTART</button>
                        <button onclick="backToMenu()">MENU</button>
                        <button onclick="toggleSound()">SOUND: <span id="soundStatus">ON</span></button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="win-screen" id="winScreen">
        <div class="win-message">
            GRID COMPLETED!<br>
            <button onclick="backToMenu()">CONTINUE</button>
        </div>
    </div>
    
    <div class="lose-screen" id="loseScreen">
        <div class="lose-message">
            SYSTEM ERROR<br>
            TOO MANY MISTAKES<br>
            <button onclick="backToMenu()">RETRY</button>
        </div>
    </div>

    <script>
        class SudokuGame {
            constructor() {
                this.grid = [];
                this.solution = [];
                this.size = 4; // Default to 4x4 as requested
                this.difficulty = 'medium';
                this.autoCheck = true;
                this.mistakes = 0;
                this.hintsUsed = 0;
                this.timeStarted = null;
                this.timerInterval = null;
                this.activeCell = null;
                this.soundEnabled = true;
                this.audioContext = null;
                this.initAudio();
            }
            
            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
            
            playSound(type) {
                if (!this.soundEnabled || !this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                switch (type) {
                    case 'correct':
                        oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.1);
                        break;
                    case 'error':
                        oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + 0.3);
                        gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.3);
                        break;
                    case 'hint':
                        oscillator.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.2);
                        break;
                    case 'win':
                        for (let i = 0; i < 3; i++) {
                            setTimeout(() => {
                                const osc = this.audioContext.createOscillator();
                                const gain = this.audioContext.createGain();
                                osc.connect(gain);
                                gain.connect(this.audioContext.destination);
                                osc.frequency.setValueAtTime(800 + i * 200, this.audioContext.currentTime);
                                gain.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                                osc.start();
                                osc.stop(this.audioContext.currentTime + 0.3);
                            }, i * 100);
                        }
                        break;
                }
            }
            
            generatePuzzle() {
                this.grid = Array(this.size).fill().map(() => Array(this.size).fill(0));
                this.solution = Array(this.size).fill().map(() => Array(this.size).fill(0));
                
                // Generate a complete valid solution
                this.solveSudoku(this.solution);
                
                // Copy solution to grid
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        this.grid[i][j] = this.solution[i][j];
                    }
                }
                
                // Remove numbers based on difficulty
                const cellsToRemove = this.getCellsToRemove();
                const positions = [];
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        positions.push([i, j]);
                    }
                }
                
                // Shuffle positions
                for (let i = positions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [positions[i], positions[j]] = [positions[j], positions[i]];
                }
                
                // Remove numbers
                for (let i = 0; i < cellsToRemove && i < positions.length; i++) {
                    const [row, col] = positions[i];
                    this.grid[row][col] = 0;
                }
            }
            
            getCellsToRemove() {
                const totalCells = this.size * this.size;
                const difficultyMap = {
                    easy: Math.floor(totalCells * 0.4),
                    medium: Math.floor(totalCells * 0.55),
                    hard: Math.floor(totalCells * 0.7)
                };
                return difficultyMap[this.difficulty] || difficultyMap.medium;
            }
            
            solveSudoku(grid) {
                for (let row = 0; row < this.size; row++) {
                    for (let col = 0; col < this.size; col++) {
                        if (grid[row][col] === 0) {
                            const numbers = Array.from({length: this.size}, (_, i) => i + 1);
                            // Shuffle numbers for randomization
                            for (let i = numbers.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [numbers[i], numbers[j]] = [numbers[j], numbers[i]];
                            }
                            
                            for (const num of numbers) {
                                if (this.isValidMove(grid, row, col, num)) {
                                    grid[row][col] = num;
                                    if (this.solveSudoku(grid)) {
                                        return true;
                                    }
                                    grid[row][col] = 0;
                                }
                            }
                            return false;
                        }
                    }
                }
                return true;
            }
            
            isValidMove(grid, row, col, num) {
                // Check row
                for (let x = 0; x < this.size; x++) {
                    if (grid[row][x] === num) return false;
                }
                
                // Check column
                for (let x = 0; x < this.size; x++) {
                    if (grid[x][col] === num) return false;
                }
                
                // Check box
                const boxSize = Math.sqrt(this.size);
                const boxRow = Math.floor(row / boxSize) * boxSize;
                const boxCol = Math.floor(col / boxSize) * boxSize;
                
                for (let i = 0; i < boxSize; i++) {
                    for (let j = 0; j < boxSize; j++) {
                        if (grid[boxRow + i][boxCol + j] === num) return false;
                    }
                }
                
                return true;
            }
            
            renderGrid() {
                const gridElement = document.getElementById('sudokuGrid');
                gridElement.innerHTML = '';
                gridElement.className = `sudoku-grid grid-${this.size}x${this.size}`;
                
                // Update number pad based on grid size
                this.updateNumberPad();
                
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'sudoku-cell';
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        
                        if (this.grid[i][j] !== 0) {
                            cell.textContent = this.grid[i][j];
                            if (this.solution[i][j] === this.grid[i][j]) {
                                cell.classList.add('prefilled');
                            }
                        }
                        
                        cell.addEventListener('click', () => this.selectCell(i, j));
                        cell.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            this.selectCell(i, j);
                        }, { passive: false });
                        gridElement.appendChild(cell);
                    }
                }
            }
            
            updateNumberPad() {
                const numberPad = document.getElementById('numberPad');
                numberPad.innerHTML = '';
                
                // Create buttons for numbers 1 to size
                for (let i = 1; i <= this.size; i++) {
                    const button = document.createElement('button');
                    button.textContent = i;
                    button.addEventListener('click', () => this.inputNumber(i));
                    button.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.inputNumber(i);
                    }, { passive: false });
                    numberPad.appendChild(button);
                }
                
                // Add clear button
                const clearButton = document.createElement('button');
                clearButton.textContent = 'CLEAR';
                clearButton.className = 'clear';
                clearButton.addEventListener('click', () => this.inputNumber(0));
                clearButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.inputNumber(0);
                }, { passive: false });
                numberPad.appendChild(clearButton);
                
                // Adjust grid columns based on size
                if (this.size <= 4) {
                    numberPad.style.gridTemplateColumns = 'repeat(2, 1fr)';
                } else if (this.size <= 6) {
                    numberPad.style.gridTemplateColumns = 'repeat(3, 1fr)';
                } else {
                    numberPad.style.gridTemplateColumns = 'repeat(5, 1fr)';
                    clearButton.style.gridColumn = 'span 2';
                }
            }
            
            selectCell(row, col) {
                // Don't select prefilled cells
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (cell.classList.contains('prefilled')) return;
                
                // Remove active class from all cells
                document.querySelectorAll('.sudoku-cell').forEach(c => c.classList.remove('active'));
                
                // Add active class to selected cell
                cell.classList.add('active');
                this.activeCell = { row, col };
            }
            
            inputNumber(num) {
                if (!this.activeCell) return;
                
                const { row, col } = this.activeCell;
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                
                if (cell.classList.contains('prefilled')) return;
                
                // Clear cell if same number is entered or 0 is pressed
                if (this.grid[row][col] === num || num === 0) {
                    this.grid[row][col] = 0;
                    cell.textContent = '';
                    return;
                }
                
                this.grid[row][col] = num;
                cell.textContent = num;
                
                if (this.autoCheck) {
                    if (this.solution[row][col] !== num) {
                        this.handleMistake(cell);
                        return;
                    }
                }
                
                this.playSound('correct');
                this.createSparkles(cell);
                
                if (this.checkWin()) {
                    this.handleWin();
                }
            }
            
            handleMistake(cell) {
                this.mistakes++;
                this.playSound('error');
                cell.classList.add('error');
                
                setTimeout(() => {
                    cell.classList.remove('error');
                }, 500);
                
                this.updateMistakeDisplay();
                
                if (this.mistakes >= 3) {
                    this.handleLose();
                }
            }
            
            updateMistakeDisplay() {
                const mistakeElement = document.getElementById('mistakes');
                mistakeElement.textContent = `${this.mistakes}/3`;
                
                if (this.mistakes >= 2) {
                    mistakeElement.classList.add('danger');
                } else {
                    mistakeElement.classList.remove('danger');
                }
            }
            
            createSparkles(element) {
                for (let i = 0; i < 5; i++) {
                    const sparkle = document.createElement('div');
                    sparkle.className = 'sparkle';
                    sparkle.style.left = Math.random() * element.offsetWidth + 'px';
                    sparkle.style.top = Math.random() * element.offsetHeight + 'px';
                    element.appendChild(sparkle);
                    
                    setTimeout(() => sparkle.remove(), 600);
                }
            }
            
            checkWin() {
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.grid[i][j] === 0 || this.grid[i][j] !== this.solution[i][j]) {
                            return false;
                        }
                    }
                }
                return true;
            }
            
            handleWin() {
                clearInterval(this.timerInterval);
                this.playSound('win');
                document.getElementById('status').textContent = 'COMPLETED!';
                setTimeout(() => {
                    document.getElementById('winScreen').style.display = 'flex';
                }, 1000);
            }
            
            handleLose() {
                clearInterval(this.timerInterval);
                document.getElementById('status').textContent = 'FAILED';
                
                // Flash white before showing lose screen
                const loseScreen = document.getElementById('loseScreen');
                loseScreen.style.display = 'flex';
                loseScreen.style.animation = 'flash-white 0.5s';
                
                setTimeout(() => {
                    loseScreen.style.animation = '';
                }, 500);
            }
            
            getHint() {
                if (this.hintsUsed >= 3) return;
                
                const emptyCells = [];
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.grid[i][j] === 0) {
                            emptyCells.push([i, j]);
                        }
                    }
                }
                
                if (emptyCells.length === 0) return;
                
                const [row, col] = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                
                this.grid[row][col] = this.solution[row][col];
                cell.textContent = this.solution[row][col];
                cell.classList.add('prefilled');
                
                this.hintsUsed++;
                document.getElementById('hints').textContent = 3 - this.hintsUsed;
                
                this.playSound('hint');
                this.createSparkles(cell);
                
                if (this.checkWin()) {
                    this.handleWin();
                }
            }
            
            startTimer() {
                this.timeStarted = Date.now();
                this.timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.timeStarted) / 1000);
                    const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                    const seconds = (elapsed % 60).toString().padStart(2, '0');
                    document.getElementById('timer').textContent = `${minutes}:${seconds}`;
                }, 1000);
            }
            
            reset() {
                this.mistakes = 0;
                this.hintsUsed = 0;
                this.activeCell = null;
                clearInterval(this.timerInterval);
                this.updateMistakeDisplay();
                document.getElementById('hints').textContent = '3';
                document.getElementById('status').textContent = 'PLAYING';
                document.getElementById('timer').textContent = '00:00';
            }
        }
        
        const game = new SudokuGame();
        
        function startGame() {
            game.size = parseInt(document.getElementById('gridSize').value);
            game.difficulty = document.getElementById('difficulty').value;
            game.autoCheck = document.getElementById('autoCheck').value === 'true';
            
            game.reset();
            game.generatePuzzle();
            game.renderGrid();
            game.startTimer();
            
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
        }
        
        function restartGame() {
            game.size = parseInt(document.getElementById('gridSize').value);
            game.difficulty = document.getElementById('difficulty').value;
            game.autoCheck = document.getElementById('autoCheck').value === 'true';
            
            game.reset();
            game.generatePuzzle();
            game.renderGrid();
            game.startTimer();
        }
        
        function backToMenu() {
            game.reset();
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('winScreen').style.display = 'none';
            document.getElementById('loseScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }
        
        function getHint() {
            game.getHint();
        }
        
        function inputNumber(num) {
            game.inputNumber(num);
        }
        
        function toggleSound() {
            game.soundEnabled = !game.soundEnabled;
            document.getElementById('soundStatus').textContent = game.soundEnabled ? 'ON' : 'OFF';
        }
        
        // Keyboard input
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('gameScreen').style.display === 'none') return;
            
            const num = parseInt(e.key);
            if (num >= 1 && num <= game.size) {
                game.inputNumber(num);
            } else if (e.key === 'Backspace' || e.key === 'Delete') {
                if (game.activeCell) {
                    const { row, col } = game.activeCell;
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    if (!cell.classList.contains('prefilled')) {
                        game.grid[row][col] = 0;
                        cell.textContent = '';
                    }
                }
            }
        });
        
        // Initialize audio context on first user interaction
        document.addEventListener('click', () => {
            if (game.audioContext && game.audioContext.state === 'suspended') {
                game.audioContext.resume();
            }
        }, { once: true });
        
        // Arrow key navigation
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('gameScreen').style.display === 'none') return;
            if (!game.activeCell) return;
            
            const { row, col } = game.activeCell;
            let newRow = row;
            let newCol = col;
            
            switch (e.key) {
                case 'ArrowUp':
                    newRow = Math.max(0, row - 1);
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                    newRow = Math.min(game.size - 1, row + 1);
                    e.preventDefault();
                    break;
                case 'ArrowLeft':
                    newCol = Math.max(0, col - 1);
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                    newCol = Math.min(game.size - 1, col + 1);
                    e.preventDefault();
                    break;
                case 'h':
                case 'H':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        getHint();
                    }
                    break;
                case 'r':
                case 'R':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        restartGame();
                    }
                    break;
            }
            
            if (newRow !== row || newCol !== col) {
                game.selectCell(newRow, newCol);
            }
        });
        
        // Set default to 4x4 medium as requested
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('gridSize').value = '4';
            document.getElementById('difficulty').value = 'medium';
            
            // Add event listener to start button
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('startBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                startGame();
            }, { passive: false });
        });
    </script>
</body>
</html>